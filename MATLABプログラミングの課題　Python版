import numpy as np
import matplotlib.pyplot as plt

# Task 1: Create a Rectangular Wave Using Fourier Series
def rectangular_wave_fourier(amplitude=1, n_terms=10):
    T = 2 * np.pi  # Period of the square wave
    t = np.linspace(0, T, 1000)  # Time array
    square_wave = np.zeros_like(t)  # Initialize square wave
    # Approximate square wave using Fourier series
    for n in range(1, n_terms * 2, 2):
        square_wave += (4 / (np.pi * n)) * np.sin(n * 2 * np.pi * t / T)
    square_wave = (square_wave + 1) / 2 * amplitude  # Scale to [0V, amplitude]
    return t, square_wave

# Task 2: Create a Rectangular Wave Without Using For Loop
def rectangular_wave_without_for(amplitude=1, n_terms=10):
    T = 2 * np.pi  # Period of the square wave
    t = np.linspace(0, T, 1000)  # Time array
    # Compute harmonics all at once
    harmonics = np.array([(4 / (np.pi * n)) * np.sin(n * 2 * np.pi * t / T)
                          for n in range(1, n_terms * 2, 2)])
    square_wave = np.sum(harmonics, axis=0)  # Sum of harmonics
    square_wave = (square_wave + 1) / 2 * amplitude  # Scale to [0V, amplitude]
    return t, square_wave

# Task 3: Create a Circle with Missing 90°-180° Section
def create_incomplete_circle():
    theta = np.linspace(0, 2 * np.pi, 1000)  # Angle array
    x = np.cos(theta)  # x-coordinates
    y = np.sin(theta)  # y-coordinates
    mask = (theta < np.pi / 2) | (theta > np.pi)  # Mask to exclude 90°-180°
    return x[mask], y[mask]

# Task 4: Simulate ADC Model
def simulate_adc(input_wave, bit_resolution=4, input_range=(-1, 1)):
    # ADC resolution and input range
    levels = 2 ** bit_resolution  # Number of levels
    v_min, v_max = input_range  # Minimum and maximum input range
    delta = (v_max - v_min) / levels  # Step size

    # Quantize input wave
    quantized_output = np.clip(np.round((input_wave - v_min) / delta) * delta + v_min, v_min, v_max)
    return quantized_output

# Generate a 1V amplitude sine wave
t = np.linspace(0, 1, 1000)
sine_wave = np.sin(2 * np.pi * t)

# Generate a ramp wave with amplitude range [-1.5V, 1.5V]
ramp_wave = np.linspace(-1.5, 1.5, 1000)

# Plot each task
# Task 1
t1, square_wave = rectangular_wave_fourier()
plt.figure()
plt.plot(t1, square_wave)
plt.title("Task 1: Square Wave Generated by Fourier Series")
plt.xlabel("Time")
plt.ylabel("Voltage [V]")

# Task 2
t2, square_wave_no_for = rectangular_wave_without_for()
plt.figure()
plt.plot(t2, square_wave_no_for)
plt.title("Task 2: Square Wave Generated Without For Loop")
plt.xlabel("Time")
plt.ylabel("Voltage [V]")

# Task 3
x, y = create_incomplete_circle()
plt.figure()
plt.plot(x, y)
plt.title("Task 3: Circle with Missing 90° to 180°")
plt.xlabel("x")
plt.ylabel("y")
plt.axis("equal")

# Task 4-1: Simulate ADC with Sine Wave Input
quantized_sine = simulate_adc(sine_wave)
plt.figure()
plt.plot(t, sine_wave, label="Input Waveform (Sine Wave)")
plt.plot(t, quantized_sine, label="ADC Output", linestyle="--")
plt.title("Task 4-1: ADC Conversion Result for Sine Wave")
plt.xlabel("Time")
plt.ylabel("Voltage [V]")
plt.legend()

# Task 4-2: Simulate ADC with Ramp Wave Input
quantized_ramp = simulate_adc(ramp_wave)
plt.figure()
plt.plot(t, ramp_wave, label="Input Waveform (Ramp Wave)")
plt.plot(t, quantized_ramp, label="ADC Output", linestyle="--")
plt.title("Task 4-2: ADC Conversion Result for Ramp Wave")
plt.xlabel("Time")
plt.ylabel("Voltage [V]")
plt.legend()

plt.show()
